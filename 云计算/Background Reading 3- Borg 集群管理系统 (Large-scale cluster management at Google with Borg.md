## 1. Borg 简介与概述 (Introduction & Overview)

### 1.1 什么是 Borg

- Borg 是 Google 开发的大规模集群管理系统，用于运行成千上万不同应用的数十万个作业
- 在单个集群中可管理多达数万台机器
- 可以视为数据中心级别的操作系统 (Datacenter OS)

### 1.2 Borg 的三大核心优势

1. **简化资源管理** (Hide the details)：隐藏资源管理和故障处理的细节，让开发者专注于应用开发
2. **高可靠性和可用性** (High reliability and availability)：支持高可用应用，最小化故障恢复时间
3. **高效利用资源** (Effective resource utilization)：通过高效的任务打包、过度承诺和机器共享来实现高利用率

### 1.3 Borg 的目标用户

- Google 开发者和系统管理员 (Site Reliability Engineers 或 SREs)
- 这些用户通过向 Borg 提交作业来运行 Google 的应用和服务

## 2. 工作负载与集群组织 (Workload & Cluster Organization)

### 2.1 两种主要工作负载类型

1. **长期运行服务** (Long-running services / Production jobs):
    - 特点：应该"永不"停机、对延迟敏感
    - 用途：面向终端用户的产品 (如 Gmail、Google Docs、网页搜索)
    - 约占 CPU 资源分配的 70%，内存分配的 55%
2. **批处理作业** (Batch jobs / Non-production jobs):
    - 特点：运行时间从几秒到几天不等，对短期性能波动不敏感
    - 用途：数据处理、分析任务、内部基础设施
    - 对资源需求变化较大

### 2.2 集群组织与规模

- **Cell (单元)**：被 Borg 管理的集群单位
- 典型 cell 规模：约 10,000 台机器
- 一个 cluster (集群) 通常包含一个大型 cell 和几个小型特殊用途的 cell
- Machines (机器) 在多个维度上具有异构性：
    - 尺寸 (CPU、RAM、磁盘、网络)
    - 处理器类型和性能
    - 特殊能力 (如外部 IP 地址或闪存)

## 3. 作业与任务 (Jobs and Tasks)

### 3.1 作业 (Job) 特性

- **定义**：用户提交给 Borg 的工作单位
- 每个作业包含一组运行相同程序的任务 (tasks)
- 一个作业只在一个 cell 中运行
- 作业属性包括：名称、所有者、任务数量、资源约束条件等
- 约束条件可以是硬性 (必须满足) 或软性 (优先考虑)

### 3.2 任务 (Task) 特性

- **定义**：作业中的单个实例，对应一组在容器中运行的 Linux 进程
- 每个任务有自己的资源需求和限制
- 大多数 Borg 工作负载直接在容器中运行，而非虚拟机
- 每个资源维度 (CPU、内存、磁盘空间、磁盘访问率、TCP 端口等) 可以独立指定

### 3.3 作业提交与配置

- 用户通过远程过程调用 (RPC) 操作作业
- 大多数作业描述使用 BCL (Borg Configuration Language) 编写
- BCL 是 GCL 的变体，扩展了 Borg 特定的关键字
- 有数以万计的 BCL 文件超过 1000 行长

### 3.4 任务生命周期状态

任务可以经历以下状态:

- **Pending (待处理)**：已提交但尚未调度
- **Running (运行中)**：已分配资源并正在执行
- **Dead (终止)**：任务已完成或被终止

状态变化可由用户操作触发 (提交、杀死、更新) 或系统操作触发 (拒绝、驱逐、丢失、失败)

## 4. Borg 架构 (Borg Architecture)

### 4.1 整体架构

- Borg 集群包含成千上万台机器，通过数据中心级网络互联
- 每个 cell 由两个主要组件组成:
    - **BorgMaster**：逻辑上集中的控制器
    - **Borglets**：运行在每台机器上的代理程序

### 4.2 BorgMaster 详解

- BorgMaster 包含两个主要进程：
    1. 主 BorgMaster 进程：处理客户端 RPC、管理状态机
    2. 独立的调度器进程：分配任务到机器
- **高可用性设计**:
    - 采用 5 个副本进行复制
    - 每个副本在内存中维护 cell 状态的副本
    - 使用基于 Paxos 的存储记录状态
    - 选举产生的主副本处理改变 cell 状态的操作
- **状态持久化**:
    - 定期创建 checkpoint 文件 (检查点)
    - 检查点可用于性能研究或恢复早期状态

### 4.3 Borglet 详解

- 运行在 cell 中每台机器上的代理程序
- 主要功能:
    - 启动和停止任务
    - 重启失败的任务
    - 管理本地资源 (通过操作系统内核设置)
    - 向 BorgMaster 报告机器状态
    - 执行 BorgMaster 下达的命令
- BorgMaster 每隔几秒轮询每个 Borglet 获取状态更新
- 如果 Borglet 不响应多次轮询，其机器被标记为宕机，任务被重新调度

## 5. 调度系统 (Scheduling System)

### 5.1 任务调度流程

- 调度器周期性地以轮询方式扫描待处理任务队列
- 按优先级从高到低处理，同一优先级内采用轮询方式确保公平性
- 调度过程包含两个主要步骤:
    1. **可行性检查** (Feasibility checking)：找到满足任务约束且有足够资源的机器
    2. **评分** (Scoring)：为每台可行机器评分以选择最佳部署位置

### 5.2 调度器优化技术

为了提高调度效率，Borg 采用了多种优化技术:

1. **分数缓存** (Score caching):
    - 缓存机器评分结果直到机器或任务属性发生变化
    - 忽略资源数量的微小变化以减少缓存失效
2. **等价类** (Equivalence classes):
    - 将具有相同需求的任务分组为等价类
    - 对每个等价类只进行一次可行性检查和评分
    - 大幅减少计算量
3. **松弛随机化** (Relaxed randomization):
    - 随机检查部分机器而非全部
    - 找到"足够多"的可行机器后停止搜索
    - 显著提高大型集群的调度速度

### 5.3 负载均衡策略

- 最初 Borg 使用 **E-PVM** (Enhanced Per-Virtual-Machine) 变体进行评分
    - 将负载均匀分散到所有机器上
    - 缺点：增加资源碎片化，对大型任务不利
- 后来采用**紧凑填充策略** (compact packing)
    - 尽可能紧密填充部分机器，让其他机器保持较低负载
    - 优点：便于放置大型任务
    - 缺点：可能放大资源需求估计错误
- 当前使用**混合评分模型**
    - 结合分散和紧凑策略的优点
    - 在资源利用率和灵活性之间取得平衡

## 6. 资源管理与利用率 (Resource Management and Utilization)

### 6.1 资源分配机制

- 资源维度包括：CPU 核心、内存 (RAM)、磁盘空间、磁盘访问率、TCP 端口等
- 每个维度都可以独立、细粒度地指定
- 不使用固定大小的资源槽 (slots)
- 任务可以指定资源上限 (limits)

### 6.2 资源隔离与控制

- Borg 使用 Linux cgroups (控制组) 进行资源隔离
- cgroups 跟踪和限制进程组的资源使用
- 资源使用超出限制的后果:
    - 内存过量使用：进程被 OOM (Out of Memory) 终止
    - CPU 过量使用：进程被限速

### 6.3 资源回收机制 (Resource Reclamation)

- **核心概念**：回收已分配但未被实际消耗的资源
- BorgMaster 每隔几秒计算一次任务的资源预留量 (reservation)
- 基于 Borglet 捕获的细粒度使用情况数据
- 回收的资源用于可以容忍低质量资源的工作 (如批处理作业)

### 6.4 资源回收效果

- 在典型 cell 中，约 20% 的工作负载运行在回收的资源上
- 大多数任务使用的资源远低于其声明限制
- 如果禁用资源回收，将需要额外 20-30% 的机器
- 显著提高了整体资源利用率

### 6.5 资源分类

Borg 将资源分为两类:

1. **可压缩资源** (Compressible resources):
    - 基于速率的资源，如 CPU 周期、磁盘 I/O 带宽
    - 可以通过降低服务质量回收，而无需终止任务
2. **不可压缩资源** (Non-compressible resources):
    - 如内存、磁盘空间
    - 通常无法回收，除非终止任务
    - 当机器耗尽不可压缩资源时，Borglet 按优先级从低到高终止任务

## 7. 可靠性与可用性 (Reliability and Availability)

### 7.1 容错设计

- 即使 BorgMaster 或 Borglet 宕机，已运行的任务仍继续运行
- 机器故障被视为常态，系统设计为可优雅处理
- 任务从故障机器上重新调度到其他可用机器

### 7.2 高可用性策略

Borg 采用多种技术实现 99.99% 的可用性:

- 副本复制应对机器故障
- 准入控制避免过载
- 使用简单、低级工具部署以最小化外部依赖
- 每个 cell 相互独立，减少相关操作员错误和故障传播

### 7.3 任务驱逐与原因

任务可能因多种原因被驱逐:

- 资源不足 (out of resources)
- 优先级抢占 (preemption)
- 机器故障 (machine failure)
- 机器关闭 (machine shutdown)
- 其他系统事件

非生产任务被驱逐的频率远高于生产任务

## 8. 配额与优先级 (Quota and Priority)

### 8.1 配额系统 (Quota)

- **定义**：用户可以请求的资源上限
- 表示为特定优先级下资源数量的向量 (CPU、RAM、磁盘等)
- 配额检查是准入控制的一部分，而非调度的一部分
- 配额不足的作业在提交时立即被拒绝

### 8.2 优先级系统 (Priority)

- 表达作业的相对重要性
- 高优先级任务可以抢占低优先级任务的资源
- 不允许生产优先级任务相互抢占
- 优先级影响调度顺序与抢占决策

### 8.3 配额超卖 (Quota Overselling)

- 生产优先级配额限制在 cell 实际可用资源范围内
- 许多用户购买过多配额，以防未来资源短缺
- 低优先级作业可能被接受但因资源不足而保持待处理状态

## 9. 命名与监控 (Naming and Monitoring)

### 9.1 Borg 命名服务

- 为每个任务创建稳定的 "Borg name service" (BNS) 名称
- 包含 cell 名称、作业名称和任务编号
- Borg 将任务的主机名和端口写入 Chubby 中的文件
- BNS 名称构成任务的 DNS 名称基础

### 9.2 监控功能

- 几乎每个在 Borg 下运行的任务都包含内置 HTTP 服务器
- 发布有关任务健康状况和性能指标的信息
- Borg 监控健康检查 URL 并重启未及时响应的任务
- Sigma 提供基于 Web 的用户界面检查作业状态
- 所有作业提交和任务事件都被记录到 Infrastore 数据存储中

## 10. 经验教训与影响 (Lessons and Impact)

### 10.1 Borg 对 Kubernetes 的影响

- Borg 的许多经验教训已应用于开源 Kubernetes 系统
- Kubernetes 继承了 Borg 的许多概念，如服务抽象、命名和负载均衡

### 10.2 关键经验教训

1. **集群管理不仅仅是任务管理**
    - 需要提供命名、负载均衡等完整服务生态
2. **内省和透明度至关重要**
    - 暴露调试信息给用户而非隐藏
    - 提供多层次 UI 和调试工具
3. **主控制器是分布式系统的核心**
    - Borgmaster 从单体系统演变为核心微服务生态
    - Kubernetes 从一开始就采用 API 服务器作为核心

### 10.3 影响与应用范围

- 几乎所有 Google 的集群工作负载在过去十年都迁移到了 Borg
- Borg 管理着 Google 的核心业务应用，如搜索、Gmail、地图、Docs 等
- Kubernetes 作为 Borg 的开源继承者，已成为容器编排领域的标准

## 总结

Borg 是 Google 开发的大规模集群管理系统，处理从短期批处理到长期服务的多样化工作负载。它通过自动资源管理、高效调度和资源回收实现了高利用率，同时保持高可靠性。系统的核心组件是 BorgMaster(控制器)和 Borglet(节点代理)，它们共同确保任务正确分配和执行。Borg 的配额和优先级系统帮助管理资源分配，而其监控和命名服务支持大规模部署和维护。经过十多年的生产实践，Borg 已成为现代容器编排系统(如 Kubernetes)的基础，代表了大规模分布式系统管理的典范。